
================================================================================
File Path: .\client\dto\KhoaTideResponse.java
================================================================================

package com.ocean.piuda.environment.client.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.List;

/**
 * KHOA 조위 API 응답 DTO
 */
@Data
@JsonIgnoreProperties(ignoreUnknown = true)
public class KhoaTideResponse {
    @JsonProperty("response")
    private Response response;

    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class Response {
        @JsonProperty("header")
        private Header header;

        @JsonProperty("body")
        private Body body;
    }

    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class Header {
        @JsonProperty("resultCode")
        private String resultCode;

        @JsonProperty("resultMsg")
        private String resultMsg;
    }

    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class Body {
        @JsonProperty("items")
        private List<Item> items;
    }

    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class Item {
        @JsonProperty("obs_post_id")
        private String obsPostId;

        @JsonProperty("obs_post_nm")
        private String obsPostNm;

        @JsonProperty("obs_dt")
        private String obsDt; // 관측일시 (yyyyMMddHHmm)

        @JsonProperty("tide_level")
        private Double tideLevel; // 조위 (cm)
    }
}



================================================================================
File Path: .\client\dto\KmaSeaObsResponse.java
================================================================================

package com.ocean.piuda.environment.client.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.List;

/**
 * KMA 해양기상종합관측 API 응답 DTO
 */
@Data
@JsonIgnoreProperties(ignoreUnknown = true)
public class KmaSeaObsResponse {
    @JsonProperty("list")
    private List<Item> list;

    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class Item {
        @JsonProperty("stn")
        private String stn; // 관측소 번호

        @JsonProperty("stn_nm")
        private String stnNm; // 관측소 이름

        @JsonProperty("tm")
        private String tm; // 관측시각 (yyyyMMddHHmm)

        @JsonProperty("lat")
        private Double lat; // 위도

        @JsonProperty("lon")
        private Double lon; // 경도

        @JsonProperty("WH")
        private Double wh; // 파고 (m)

        @JsonProperty("WD")
        private Double wd; // 풍향 (도)

        @JsonProperty("WS")
        private Double ws; // 풍속 (m/s)

        @JsonProperty("TW")
        private Double tw; // 해수면 온도 (℃)
    }
}



================================================================================
File Path: .\client\dto\NifsRisaResponse.java
================================================================================

package com.ocean.piuda.environment.client.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;

import java.util.List;

/**
 * NIFS RISA API 응답 DTO
 */
@Data
@JsonIgnoreProperties(ignoreUnknown = true)
public class NifsRisaResponse {
    @JsonProperty("body")
    private Body body;

    @JsonProperty("header")
    private Header header;

    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class Body {
        @JsonProperty("item")
        private List<NifsRisaItem> item;
    }

    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class Header {
        @JsonProperty("resultCode")
        private String resultCode;

        @JsonProperty("resultMsg")
        private String resultMsg;
    }

    @Data
    @JsonIgnoreProperties(ignoreUnknown = true)
    @Slf4j // 내부 클래스에 직접 로그 어노테이션 적용
    public static class NifsRisaItem {
        @JsonProperty("sta_cde")
        private String staCde; // 관측소 코드 (기존 obs_post_id)

        @JsonProperty("sta_nam_kor")
        private String staNamKor; // 관측소 이름 (기존 obs_post_nm)

        @JsonProperty("obs_lay")
        private String obsLay; // 수층 (1: 표층, 2: 중층, 3: 저층)

        @JsonProperty("wtr_tmp")
        private String wtrTmp; // 수온 (기존 water_temp)

        @JsonProperty("obs_dat")
        private String obsDat; // 관측일

        @JsonProperty("obs_tim")
        private String obsTim; // 관측시각

        // 파싱된 값 캐싱용 (JSON 직렬화 제외)
        private transient Integer obsLayIntCached;
        private transient Double waterTempCached;

        // 관측소 위치 정보는 별도 API로 가져와야 할 수 있음
        // 임시로 null 처리
        public Double getObsLat() {
            return null; // TODO: 관측소 위치 정보 별도 조회 필요
        }

        public Double getObsLon() {
            return null; // TODO: 관측소 위치 정보 별도 조회 필요
        }

        public String getObsPostId() {
            return staCde;
        }

        public String getObsPostNm() {
            return staNamKor;
        }

        /**
         * 수층(Integer) 파싱 + 캐싱
         */
        public Integer getObsLayInt() {
            if (obsLayIntCached != null) {
                return obsLayIntCached;
            }

            if (obsLay == null || obsLay.isBlank()) {
                return null;
            }

            try {
                obsLayIntCached = Integer.parseInt(obsLay.trim());
                return obsLayIntCached;
            } catch (NumberFormatException e) {
                log.warn("수층(obs_lay) 파싱 실패: sta_cde={}, obs_lay={}", staCde, obsLay);
                return null;
            }
        }

        /**
         * 수온(Double) 파싱 + 캐싱
         * - 빈 값 / -99 / -99.0 등은 데이터 없음으로 처리
         */
        public Double getWaterTemp() {
            if (waterTempCached != null) {
                return waterTempCached;
            }

            if (wtrTmp == null || wtrTmp.isBlank()) {
                return null;
            }

            String value = wtrTmp.trim();
            if ("-99".equals(value) || "-99.0".equals(value)) {
                // 관측값 없음
                return null;
            }

            try {
                waterTempCached = Double.parseDouble(value);
                return waterTempCached;
            } catch (NumberFormatException e) {
                log.warn("수온(wtr_tmp) 파싱 실패: sta_cde={}, wtr_tmp={}", staCde, wtrTmp);
                return null;
            }
        }

        // 염분과 용존산소는 현재 API 응답에 없음
        public Double getSalinity() {
            return null;
        }

        public Double getDissolvedOxygen() {
            return null;
        }
    }
}


================================================================================
File Path: .\client\KhoaTideClient.java
================================================================================

package com.ocean.piuda.environment.client;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.ocean.piuda.environment.client.dto.KhoaTideResponse;
import com.ocean.piuda.environment.properties.MarineApiProperties;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

/**
 * KHOA 조위 관측 API 클라이언트
 */
@Slf4j
@Component
public class KhoaTideClient {

    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyyMMdd");
    private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HHmm");

    private final WebClient webClient;
    private final MarineApiProperties properties;
    private final ObjectMapper objectMapper;

    public KhoaTideClient(
            @Qualifier("marineWebClient") WebClient marineWebClient,
            MarineApiProperties properties,
            ObjectMapper objectMapper
    ) {
        this.webClient = marineWebClient;
        this.properties = properties;
        this.objectMapper = objectMapper;
    }

    /**
     * 조위 관측값 조회
     */
    public Mono<KhoaTideResponse.Item> fetchTideLevel(String stationId, LocalDate date, LocalTime time) {
        String dateStr = date.format(DATE_FORMATTER);

        return webClient.get()
                .uri(uriBuilder -> {
                    MarineApiProperties.Khoa config = properties.getKhoa();

                    var builder = uriBuilder
                            .scheme("https")
                            .host(config.getHost())
                            .path(config.getTidePath())
                            .queryParam("ServiceKey", config.getKeyEncoding()) // 인코딩된 키 사용
                            .queryParam("obs_post_id", stationId)
                            .queryParam("date", dateStr)
                            .queryParam("ResultType", "json"); // JSON 포맷 명시

                    if (time != null) {
                        builder.queryParam("time", time.format(TIME_FORMATTER));
                    }

                    return builder.build();
                })
                .retrieve()
                // [확정] KHOA는 UTF-8이므로 String으로 받음
                .bodyToMono(String.class)
                .flatMap(response -> {
                    try {
                        if (response == null || response.trim().isEmpty() || response.contains("Unexpected errors")) {
                            log.warn("KHOA API 오류 응답: stationId={}, response={}", stationId, response);
                            return Mono.empty();
                        }

                        // 정상 JSON 응답인지 확인 (간단한 체크)
                        if (!response.trim().startsWith("{")) {
                            log.warn("KHOA API 응답이 JSON이 아닙니다: stationId={}, response={}", stationId, response);
                            return Mono.empty();
                        }

                        KhoaTideResponse parsed = objectMapper.readValue(response, KhoaTideResponse.class);
                        if (parsed.getResponse() == null
                                || parsed.getResponse().getBody() == null
                                || parsed.getResponse().getBody().getItems() == null
                                || parsed.getResponse().getBody().getItems().isEmpty()) {
                            log.warn("KHOA 조위 데이터가 없습니다: stationId={}, date={}", stationId, date);
                            return Mono.empty();
                        }

                        return Mono.just(parsed.getResponse().getBody().getItems().get(0));
                    } catch (Exception e) {
                        log.error("KHOA 조위 응답 파싱 실패: stationId={}, date={}, response={}",
                                stationId, date,
                                response != null ? response.substring(0, Math.min(500, response.length())) : "null",
                                e);
                        return Mono.empty();
                    }
                })
                .doOnError(error -> {
                    if (error instanceof org.springframework.web.reactive.function.client.WebClientResponseException webClientError) {
                        if (webClientError.getStatusCode().value() == 500) {
                            log.warn("KHOA 조위 API 서버 오류 (500): stationId={}, 외부 서버 문제 또는 키/파라미터 확인 필요.", stationId);
                        } else {
                            log.error("KHOA 조위 API 호출 실패: stationId={}, status={}",
                                    stationId, webClientError.getStatusCode(), error);
                        }
                    } else {
                        log.error("KHOA 조위 API 호출 실패: stationId={}", stationId, error);
                    }
                })
                .onErrorResume(error -> Mono.empty());
    }

    public Mono<KhoaTideResponse.Item> fetchLatestTideLevel(String stationId) {
        return fetchTideLevel(stationId, LocalDate.now(), null);
    }
}


================================================================================
File Path: .\client\KmaSeaObsClient.java
================================================================================

package com.ocean.piuda.environment.client;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.ocean.piuda.environment.client.dto.KmaSeaObsResponse;
import com.ocean.piuda.environment.properties.MarineApiProperties;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

import java.nio.charset.Charset;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

/**
 * KMA 해양기상종합관측 API 클라이언트
 */
@Slf4j
@Component
public class KmaSeaObsClient {

    private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("yyyyMMddHHmm");
    // [필수] KMA는 EUC-KR 인코딩을 사용함
    private static final Charset EUC_KR = Charset.forName("EUC-KR");

    private final WebClient webClient;
    private final MarineApiProperties properties;
    @SuppressWarnings("unused")
    private final ObjectMapper objectMapper;

    public KmaSeaObsClient(
            @Qualifier("marineWebClient") WebClient marineWebClient,
            MarineApiProperties properties,
            ObjectMapper objectMapper
    ) {
        this.webClient = marineWebClient;
        this.properties = properties;
        this.objectMapper = objectMapper;
    }

    /**
     * 해양기상 관측값 조회
     */
    public Mono<List<KmaSeaObsResponse.Item>> fetchObservations(String stationId, LocalDateTime dateTime) {
        String tm = dateTime.format(DATE_TIME_FORMATTER);

        return webClient.get()
                .uri(uriBuilder -> {
                    MarineApiProperties.Kma config = properties.getKma();
                    return uriBuilder
                            .scheme("https")
                            .host(config.getHost())
                            .path(config.getSeaObsPath())
                            .queryParam("tm", tm)
                            .queryParam("stn", stationId)
                            .queryParam("authKey", config.getKey())
                            .build();
                })
                .retrieve()
                // [중요] byte[]로 받아서 EUC-KR로 디코딩
                .bodyToMono(byte[].class)
                .map(bytes -> new String(bytes, EUC_KR))
                .map(response -> {
                    try {
                        return parseKmaTextResponse(response, stationId);
                    } catch (Exception e) {
                        log.error("KMA 해양기상 응답 파싱 실패: stationId={}, dateTime={}", stationId, dateTime, e);
                        if (response != null) {
                            log.debug("KMA 응답 내용: {}", response.substring(0, Math.min(500, response.length())));
                        }
                        return new ArrayList<KmaSeaObsResponse.Item>();
                    }
                })
                .doOnError(error -> log.error("KMA 해양기상 API 호출 실패: stationId={}", stationId, error))
                .onErrorResume(error -> Mono.just(new ArrayList<>()));
    }

    public Mono<KmaSeaObsResponse.Item> fetchLatestObservation(String stationId) {
        return fetchObservations(stationId, LocalDateTime.now())
                .flatMap(items -> items.isEmpty()
                        ? Mono.empty()
                        : Mono.just(items.get(0)));
    }

    /**
     * KMA 텍스트 형식 응답 파싱
     */
    private List<KmaSeaObsResponse.Item> parseKmaTextResponse(String text, String targetStationId) {
        List<KmaSeaObsResponse.Item> items = new ArrayList<>();

        if (text == null || text.trim().isEmpty() || text.contains("unexpected errors")) {
            log.warn("KMA API 응답이 비어있거나 오류가 있습니다.");
            return items;
        }

        String[] lines = text.split("\n");
        for (String line : lines) {
            line = line.trim();
            if (line.startsWith("#") || line.isEmpty() || line.startsWith("START") || line.startsWith("END")) {
                continue;
            }

            if (line.startsWith("B,") || line.startsWith("C,")) {
                try {
                    String[] parts = line.split(",");
                    if (parts.length < 14) {
                        continue;
                    }

                    String stn = parts[2].trim();
                    if (targetStationId != null && !targetStationId.equals("0") && !targetStationId.equals(stn)) {
                        continue;
                    }

                    KmaSeaObsResponse.Item item = new KmaSeaObsResponse.Item();
                    item.setStn(stn);
                    item.setStnNm(parts[3].trim());
                    item.setTm(parts[1].trim());

                    try {
                        item.setLon(Double.parseDouble(parts[4].trim()));
                        item.setLat(Double.parseDouble(parts[5].trim()));
                    } catch (Exception e) {
                        log.warn("좌표 파싱 실패: {}", line);
                    }

                    // WH
                    try {
                        String whStr = parts[6].trim();
                        if (!whStr.equals("-99.0") && !whStr.equals("-99") && !whStr.isEmpty()) {
                            item.setWh(Double.parseDouble(whStr));
                        }
                    } catch (Exception e) {
                        log.debug("파고(WH) 파싱 실패: stn={}, value={}", stn, parts[6]);
                    }

                    // WD
                    try {
                        String wdStr = parts[7].trim();
                        if (!wdStr.equals("-99") && !wdStr.equals("-99.0") && !wdStr.isEmpty()) {
                            item.setWd(Double.parseDouble(wdStr));
                        }
                    } catch (Exception e) {
                        log.debug("풍향(WD) 파싱 실패: stn={}, value={}", stn, parts[7]);
                    }

                    // WS
                    try {
                        String wsStr = parts[8].trim();
                        if (!wsStr.equals("-99.0") && !wsStr.equals("-99") && !wsStr.isEmpty()) {
                            item.setWs(Double.parseDouble(wsStr));
                        }
                    } catch (Exception e) {
                        log.warn("풍속(WS) 파싱 실패: stn={}, value={}, error={}", stn, parts[8], e.getMessage());
                    }

                    // TW
                    try {
                        String twStr = parts[10].trim();
                        if (!twStr.equals("-99.0") && !twStr.equals("-99") && !twStr.isEmpty()) {
                            item.setTw(Double.parseDouble(twStr));
                        }
                    } catch (Exception e) {
                        log.debug("해수온(TW) 파싱 실패: stn={}, value={}", stn, parts[10]);
                    }

                    items.add(item);
                } catch (Exception e) {
                    log.warn("KMA 데이터 라인 파싱 실패: {}", line, e);
                }
            }
        }

        return items;
    }
}


================================================================================
File Path: .\client\NifsRisaClient.java
================================================================================

package com.ocean.piuda.environment.client;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.ocean.piuda.environment.client.dto.NifsRisaResponse;
import com.ocean.piuda.environment.properties.MarineApiProperties;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;

/**
 * NIFS RISA 실시간 해양수산환경 관측 API 클라이언트
 */
@Slf4j
@Component
public class NifsRisaClient {

    private static final List<Integer> LAYER_PRIORITY = List.of(2, 1, 3); // 중층 -> 표층 -> 저층 순
    // [필수] NIFS는 EUC-KR 인코딩을 사용함 (헤더도 없음)
    private static final Charset EUC_KR = Charset.forName("EUC-KR");

    private final WebClient webClient;
    private final MarineApiProperties properties;
    private final ObjectMapper objectMapper;

    public NifsRisaClient(
            @Qualifier("marineWebClient") WebClient marineWebClient,
            MarineApiProperties properties,
            ObjectMapper objectMapper
    ) {
        this.webClient = marineWebClient;
        this.properties = properties;
        this.objectMapper = objectMapper;
    }

    /**
     * 관측소 목록 조회
     */
    public Mono<List<NifsRisaResponse.NifsRisaItem>> fetchStations() {
        return webClient.get()
                .uri(uriBuilder -> {
                    MarineApiProperties.Nifs config = properties.getNifs();
                    return uriBuilder
                            .scheme("https")
                            .host(config.getHost())
                            .path(config.getRisaPath())
                            .queryParam("id", "risaList")
                            .queryParam("key", config.getKey())
                            .build();
                })
                .retrieve()
                // [중요] byte[]로 받아서 EUC-KR로 디코딩
                .bodyToMono(byte[].class)
                .map(bytes -> new String(bytes, EUC_KR))
                .map(response -> {
                    try {
                        NifsRisaResponse parsed = objectMapper.readValue(response, NifsRisaResponse.class);
                        if (parsed.getBody() != null && parsed.getBody().getItem() != null) {
                            return parsed.getBody().getItem();
                        }
                        return new ArrayList<NifsRisaResponse.NifsRisaItem>();
                    } catch (Exception e) {
                        String preview = response != null
                                ? response.substring(0, Math.min(200, response.length()))
                                : "null";
                        log.error("NIFS RISA 응답 파싱 실패: {}", preview, e);
                        return new ArrayList<NifsRisaResponse.NifsRisaItem>();
                    }
                })
                .doOnError(error -> log.error("NIFS RISA API 호출 실패", error))
                .onErrorResume(error -> Mono.just(new ArrayList<>()));
    }

    /**
     * 특정 관측소의 최신 관측값 조회
     */
    public Mono<NifsRisaResponse.NifsRisaItem> fetchLatestObservation(String stationId) {
        return webClient.get()
                .uri(uriBuilder -> {
                    MarineApiProperties.Nifs config = properties.getNifs();
                    return uriBuilder
                            .scheme("https")
                            .host(config.getHost())
                            .path(config.getRisaPath())
                            .queryParam("id", "risaList")
                            .queryParam("key", config.getKey())
                            .queryParam("sta_cde", stationId)
                            .build();
                })
                .retrieve()
                // [중요] byte[]로 받아서 EUC-KR로 디코딩
                .bodyToMono(byte[].class)
                .map(bytes -> new String(bytes, EUC_KR))
                .flatMap(response -> {
                    try {
                        NifsRisaResponse parsed = objectMapper.readValue(response, NifsRisaResponse.class);
                        if (parsed.getBody() == null || parsed.getBody().getItem() == null
                                || parsed.getBody().getItem().isEmpty()) {
                            log.warn("NIFS RISA API 응답이 비어있습니다: stationId={}", stationId);
                            return Mono.empty();
                        }

                        List<NifsRisaResponse.NifsRisaItem> allItems = parsed.getBody().getItem();
                        List<NifsRisaResponse.NifsRisaItem> stationItems = allItems.stream()
                                .filter(item -> stationId.equals(item.getStaCde()))
                                .toList();

                        if (stationItems.isEmpty()) {
                            log.warn("NIFS RISA API에서 해당 관측소 데이터를 찾을 수 없습니다: stationId={}, 전체 관측소 수={}",
                                    stationId, allItems.size());
                            return Mono.empty();
                        }

                        for (Integer layer : LAYER_PRIORITY) {
                            for (NifsRisaResponse.NifsRisaItem item : stationItems) {
                                if (item.getObsLayInt() != null && item.getObsLayInt().equals(layer)) {
                                    log.debug("NIFS RISA 관측값 조회 성공: stationId={}, layer={}, temp={}",
                                            stationId, layer, item.getWaterTemp());
                                    return Mono.just(item);
                                }
                            }
                        }

                        NifsRisaResponse.NifsRisaItem firstItem = stationItems.get(0);
                        log.debug("NIFS RISA 관측값 조회 성공 (우선순위 레이어 없음): stationId={}, layer={}, temp={}",
                                stationId, firstItem.getObsLayInt(), firstItem.getWaterTemp());
                        return Mono.just(firstItem);
                    } catch (Exception e) {
                        String preview = response != null
                                ? response.substring(0, Math.min(200, response.length()))
                                : "null";
                        log.error("NIFS RISA 관측값 파싱 실패: stationId={}, response={}", stationId, preview, e);
                        return Mono.empty();
                    }
                })
                .doOnError(error -> log.error("NIFS RISA 관측값 조회 실패: stationId={}", stationId, error))
                .onErrorResume(error -> {
                    log.warn("NIFS RISA 관측값 조회 에러 처리: stationId={}, error={} (관측소가 API에서 제공되지 않을 수 있음)",
                            stationId, error.getMessage());
                    return Mono.empty();
                });
    }
}


================================================================================
File Path: .\config\MarineWebClientConfig.java
================================================================================

package com.ocean.piuda.environment.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.client.WebClient;

/**
 * 해양 환경 API용 WebClient 설정
 */
@Configuration
public class MarineWebClientConfig {

    /**
     * 해양 환경 API 호출용 WebClient
     * 타임아웃 설정 포함
     */
    @Bean("marineWebClient")
    public WebClient marineWebClient(WebClient.Builder builder) {
        return builder
                .codecs(configurer -> configurer
                        .defaultCodecs()
                        .maxInMemorySize(10 * 1024 * 1024)) // 10MB
                .build();
    }
}


================================================================================
File Path: .\controller\EnvironmentSummaryController.java
================================================================================

package com.ocean.piuda.environment.controller;

import com.ocean.piuda.environment.dto.EnvironmentSummaryRequest;
import com.ocean.piuda.environment.dto.EnvironmentSummaryResponse;
import com.ocean.piuda.environment.service.EnvironmentSummaryService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

/**
 * 해양 환경 요약 API 컨트롤러
 */
@RestController
@RequestMapping("/api/environment")
@RequiredArgsConstructor
public class EnvironmentSummaryController {

    private final EnvironmentSummaryService environmentSummaryService;

    /**
     * 해양 환경 요약 조회
     *
     * GET /api/environment/summary?lat={lat}&lon={lon}
     * GET /api/environment/summary?pointId={pointId}
     */
    @GetMapping("/summary")
    public Mono<ResponseEntity<EnvironmentSummaryResponse>> getEnvironmentSummary(
            @RequestParam(required = false) Double lat,
            @RequestParam(required = false) Double lon,
            @RequestParam(required = false) Long pointId
    ) {
        EnvironmentSummaryRequest request = EnvironmentSummaryRequest.builder()
                .lat(lat)
                .lon(lon)
                .pointId(pointId)
                .build();

        return environmentSummaryService.getEnvironmentSummary(request)
                .map(ResponseEntity::ok);
    }
}


================================================================================
File Path: .\domain\DivePoint.java
================================================================================

package com.ocean.piuda.environment.domain;

import com.ocean.piuda.global.api.domain.BaseEntity;
import jakarta.persistence.*;
import lombok.*;
import lombok.experimental.SuperBuilder;

/**
 * 다이빙 포인트 엔티티
 * Mission에서 참조하는 다이빙 지점 정보
 */
@Entity
@Table(name = "dive_points", indexes = {
    @Index(name = "idx_dive_point_lat_lon", columnList = "lat, lon")
})
@SuperBuilder(toBuilder = true)
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
public class DivePoint extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * 포인트 이름
     */
    @Column(nullable = false, length = 200)
    private String name;

    /**
     * 위도
     */
    @Column(nullable = false, columnDefinition = "DECIMAL(9,6)")
    private Double lat;

    /**
     * 경도
     */
    @Column(nullable = false, columnDefinition = "DECIMAL(9,6)")
    private Double lon;

    /**
     * 지역명 (예: "포항 월포")
     */
    @Column(length = 200)
    private String regionName;

    /**
     * 설명
     */
    @Column(columnDefinition = "TEXT")
    private String description;
}



================================================================================
File Path: .\domain\MarineStation.java
================================================================================

package com.ocean.piuda.environment.domain;

import com.ocean.piuda.global.api.domain.BaseEntity;
import jakarta.persistence.*;
import lombok.*;
import lombok.experimental.SuperBuilder;

/**
 * 해양 관측소 엔티티
 * 외부 API에서 제공하는 관측소 정보를 저장
 */
@Entity
@Table(name = "marine_stations", indexes = {
    @Index(name = "idx_source_ext", columnList = "externalSource, externalStationId"),
    @Index(name = "idx_lat_lon", columnList = "lat, lon")
})
@SuperBuilder(toBuilder = true)
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
public class MarineStation extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * 외부 API 소스 (NIFS_RISA, KMA_SEA_OBS, KHOA_SURVEY_TIDE)
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    private StationSource externalSource;

    /**
     * 외부 API에서 사용하는 관측소 ID
     */
    @Column(nullable = false, length = 100)
    private String externalStationId;

    /**
     * 관측소 이름
     */
    @Column(nullable = false, length = 200)
    private String name;

    /**
     * 위도
     */
    @Column(nullable = false, columnDefinition = "DECIMAL(9,6)")
    private Double lat;

    /**
     * 경도
     */
    @Column(nullable = false, columnDefinition = "DECIMAL(9,6)")
    private Double lon;

    /**
     * 관측소 활성화 여부
     */
    @Builder.Default
    @Column(nullable = false)
    private Boolean isActive = true;
}



================================================================================
File Path: .\domain\StationSource.java
================================================================================

package com.ocean.piuda.environment.domain;

/**
 * 관측소 데이터 소스 Enum
 */
public enum StationSource {
    NIFS_RISA,          // 국립수산과학원 실시간 해양수산환경 관측
    KMA_SEA_OBS,        // 기상청 해양기상종합관측
    KHOA_SURVEY_TIDE    // 국립해양조사원 조위 관측
}



================================================================================
File Path: .\dto\EnvironmentSummaryRequest.java
================================================================================

package com.ocean.piuda.environment.dto;

import jakarta.validation.constraints.DecimalMax;
import jakarta.validation.constraints.DecimalMin;
import lombok.Builder;

/**
 * 환경 요약 조회 요청 DTO
 */
@Builder
public record EnvironmentSummaryRequest(
        /**
         * 위도 (-90 ~ 90)
         */
        @DecimalMin(value = "-90.0", message = "위도는 -90 ~ 90 사이여야 합니다")
        @DecimalMax(value = "90.0", message = "위도는 -90 ~ 90 사이여야 합니다")
        Double lat,

        /**
         * 경도 (-180 ~ 180)
         */
        @DecimalMin(value = "-180.0", message = "경도는 -180 ~ 180 사이여야 합니다")
        @DecimalMax(value = "180.0", message = "경도는 -180 ~ 180 사이여야 합니다")
        Double lon,

        /**
         * 다이빙 포인트 ID (pointId가 있으면 lat/lon 무시)
         */
        Long pointId
) {
    /**
     * 좌표 기반 요청인지 확인
     */
    public boolean isCoordinateBased() {
        return pointId == null && lat != null && lon != null;
    }

    /**
     * 포인트 ID 기반 요청인지 확인
     */
    public boolean isPointIdBased() {
        return pointId != null;
    }
}



================================================================================
File Path: .\dto\EnvironmentSummaryResponse.java
================================================================================

package com.ocean.piuda.environment.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Builder;

import java.time.ZonedDateTime;
import java.util.List;

/**
 * 환경 요약 응답 DTO
 */
@Builder
public record EnvironmentSummaryResponse(
        Location location,
        @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ssXXX")
        ZonedDateTime timestamp,
        Water water,
        Wave wave,
        Tide tide,
        Meta meta
) {
    @Builder
    public record Location(
            Double lat,
            Double lon,
            NearestStations nearestStations
    ) {}

    @Builder
    public record NearestStations(
            StationInfo nifs,
            StationInfo kma,
            StationInfo khoa
    ) {}

    @Builder
    public record StationInfo(
            String id,
            String name,
            Double distanceKm
    ) {}

    @Builder
    public record Water(
            Double midLayerTemp,
            Double surfaceTemp,
            Double salinity,
            Double dissolvedOxygen
    ) {}

    @Builder
    public record Wave(
            Double significantWaveHeight,
            Double windDirectionDeg,
            Double windSpeedMs
    ) {}

    @Builder
    public record Tide(
            Double tideLevelCm,
            @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ssXXX")
            ZonedDateTime tideObservedAt
    ) {}

    @Builder
    public record Meta(
            List<String> rawSources,
            String note
    ) {}
}



================================================================================
File Path: .\initializer\MarineStationInitializer.java
================================================================================

package com.ocean.piuda.environment.initializer;

import com.ocean.piuda.environment.client.KmaSeaObsClient;
import com.ocean.piuda.environment.client.NifsRisaClient;
import com.ocean.piuda.environment.client.dto.KmaSeaObsResponse;
import com.ocean.piuda.environment.client.dto.NifsRisaResponse;
import com.ocean.piuda.environment.domain.MarineStation;
import com.ocean.piuda.environment.domain.StationSource;
import com.ocean.piuda.environment.repository.MarineStationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

/**
 * 해양 관측소 데이터 초기화
 * 애플리케이션 시작 시 외부 API 및 CSV에서 관측소 목록을 가져와 데이터베이스에 저장
 *
 * [주요 변경 사항]
 * 1. 성능 최적화 (Batch Processing):
 * - 기존: for문 내에서 매번 DB 조회(Select) 및 저장(Insert) -> N+1 문제 발생
 * - 변경: 전체 ID 메모리 로드 -> 중복 검사 -> saveAll()로 일괄 저장
 * 2. 예외 처리 강화:
 * - CSV 파일이 없거나 API 호출 실패 시, 전체 로직이 중단되지 않고 해당 단계만 건너뛰도록 처리
 * 3. CSV 인코딩 처리:
 * - UTF-8 -> EUC-KR 순으로 시도 (한글 깨짐 방지)
 * 4. KHOA 파일명 및 구조 변경:
 * - 파일명: khoa-stations.csv
 * - 컬럼: [0]ID, [1]이름, [2]위도, [3]경도
 */
@Slf4j
@Component
@RequiredArgsConstructor
@Order(2) // 다른 초기화 이후 실행
public class MarineStationInitializer implements CommandLineRunner {

    private final NifsRisaClient nifsRisaClient;
    private final KmaSeaObsClient kmaSeaObsClient;
    private final MarineStationRepository marineStationRepository;

    @Override
    @Transactional
    public void run(String... args) {
        log.info("해양 관측소 데이터 초기화 시작...");

        try {
            // 1. NIFS RISA 관측소 데이터 초기화 (CSV 파일: nifs-stations.csv)
            initializeNifsRisaStationsFromCsv();

            // 2. KMA 관측소 데이터 초기화 (API 호출)
            initializeKmaStations();

            // 3. KHOA 조위관측소 데이터 초기화 (CSV 파일: khoa-stations.csv)
            initializeKhoaStationsFromCsv();

        } catch (Exception e) {
            log.error("해양 관측소 데이터 초기화 중 전체 오류 발생", e);
        }
    }

    /**
     * NIFS RISA 관측소 데이터 초기화 (Batch 최적화 적용)
     */
    private void initializeNifsRisaStationsFromCsv() {
        try {
            // 1. CSV 파일 읽기
            log.info("CSV 파일에서 NIFS 관측소 좌표 정보 읽기 중...");
            Map<String, NifsStationCsvRecord> csvStations = loadNifsStationsFromCsv();

            if (csvStations.isEmpty()) {
                log.info("NIFS 관측소 CSV 데이터가 없거나 파일을 찾을 수 없어 초기화를 건너뜁니다.");
                return;
            }
            log.info("CSV에서 {}개의 NIFS 관측소 좌표 정보 발견", csvStations.size());

            // 2. API 관측소 이름 매칭 (선택적)
            Map<String, String> apiStationNames = new HashMap<>();
            try {
                log.info("NIFS RISA API에서 관측소 목록 조회 중...");
                List<NifsRisaResponse.NifsRisaItem> apiStations = nifsRisaClient.fetchStations().block();

                if (apiStations != null && !apiStations.isEmpty()) {
                    apiStations.stream()
                            .filter(item -> item.getStaCde() != null && !item.getStaCde().isEmpty())
                            .forEach(item -> apiStationNames.put(item.getStaCde(), item.getStaNamKor()));
                    log.info("NIFS RISA API에서 {}개의 관측소 이름 정보 발견", apiStationNames.size());
                }
            } catch (Exception e) {
                log.warn("NIFS RISA API에서 관측소 목록을 가져올 수 없습니다. CSV 데이터만 사용합니다: {}", e.getMessage());
            }

            // 3. DB 중복 체크 (Batch) - 쿼리 1회 실행
            Set<String> existingIds = marineStationRepository
                    .findByExternalSourceAndIsActiveTrue(StationSource.NIFS_RISA)
                    .stream()
                    .map(MarineStation::getExternalStationId)
                    .collect(Collectors.toSet());

            // 4. 저장할 엔티티 생성
            List<MarineStation> stationsToSave = new ArrayList<>();
            int apiMatchedCount = 0;

            for (NifsStationCsvRecord csvRecord : csvStations.values()) {
                String stationId = csvRecord.stationId;

                // 이미 존재하면 건너뜀
                if (existingIds.contains(stationId)) {
                    continue;
                }

                String stationName = csvRecord.stationName;
                Double lat = csvRecord.lat;
                Double lon = csvRecord.lon;

                // API 이름 매칭
                String finalName = apiStationNames.getOrDefault(stationId, stationName);
                if (apiStationNames.containsKey(stationId)) {
                    apiMatchedCount++;
                }

                MarineStation station = MarineStation.builder()
                        .externalSource(StationSource.NIFS_RISA)
                        .externalStationId(stationId)
                        .name(finalName != null ? finalName : "관측소_" + stationId)
                        .lat(lat)
                        .lon(lon)
                        .isActive(true)
                        .build();

                stationsToSave.add(station);
            }

            // 5. 일괄 저장
            if (!stationsToSave.isEmpty()) {
                marineStationRepository.saveAll(stationsToSave);
                log.info("NIFS RISA 관측소 데이터 신규 저장 완료: {}개 (API 이름 매칭: {}개)",
                        stationsToSave.size(), apiMatchedCount);
            } else {
                log.info("NIFS RISA 관측소 데이터가 모두 최신입니다.");
            }

        } catch (Exception e) {
            log.error("NIFS RISA 관측소 데이터 초기화 실패", e);
        }
    }

    /**
     * KMA 관측소 데이터 초기화 (Batch 최적화 적용)
     */
    private void initializeKmaStations() {
        try {
            // 1. DB 중복 체크
            Set<String> existingIds = marineStationRepository
                    .findByExternalSourceAndIsActiveTrue(StationSource.KMA_SEA_OBS)
                    .stream()
                    .map(MarineStation::getExternalStationId)
                    .collect(Collectors.toSet());

            if (!existingIds.isEmpty()) {
                log.info("KMA 관측소 데이터가 이미 {}개 존재합니다.", existingIds.size());
            }

            // 2. API 호출
            List<KmaSeaObsResponse.Item> kmaItems = kmaSeaObsClient
                    .fetchObservations("0", LocalDateTime.now())
                    .block();

            if (kmaItems == null || kmaItems.isEmpty()) {
                log.warn("KMA 관측소 데이터를 가져올 수 없습니다.");
                return;
            }

            log.info("KMA API에서 관측소 {}개 발견", kmaItems.size());

            // 3. 중복 제거 및 엔티티 변환
            Map<String, KmaSeaObsResponse.Item> uniqueStations = kmaItems.stream()
                    .filter(item -> item.getStn() != null && item.getLat() != null && item.getLon() != null)
                    .collect(Collectors.toMap(
                            KmaSeaObsResponse.Item::getStn,
                            item -> item,
                            (existing, replacement) -> existing
                    ));

            List<MarineStation> stationsToSave = new ArrayList<>();

            for (KmaSeaObsResponse.Item item : uniqueStations.values()) {
                if (existingIds.contains(item.getStn())) {
                    continue;
                }

                MarineStation station = MarineStation.builder()
                        .externalSource(StationSource.KMA_SEA_OBS)
                        .externalStationId(item.getStn())
                        .name(item.getStnNm() != null ? item.getStnNm() : "KMA_" + item.getStn())
                        .lat(item.getLat())
                        .lon(item.getLon())
                        .isActive(true)
                        .build();
                stationsToSave.add(station);
            }

            // 4. 일괄 저장
            if (!stationsToSave.isEmpty()) {
                marineStationRepository.saveAll(stationsToSave);
                log.info("{}개의 KMA 신규 관측소 데이터 저장 완료", stationsToSave.size());
            } else {
                log.info("KMA 관측소 데이터가 모두 최신입니다.");
            }

        } catch (Exception e) {
            log.error("KMA 관측소 데이터 초기화 실패", e);
        }
    }

    /**
     * KHOA 조위관측소 데이터 초기화 (Batch 최적화 적용)
     */
    private void initializeKhoaStationsFromCsv() {
        try {
            // 1. DB 중복 체크
            Set<String> existingIds = marineStationRepository
                    .findByExternalSourceAndIsActiveTrue(StationSource.KHOA_SURVEY_TIDE)
                    .stream()
                    .map(MarineStation::getExternalStationId)
                    .collect(Collectors.toSet());

            if (!existingIds.isEmpty()) {
                log.info("KHOA 조위관측소 데이터가 이미 {}개 존재합니다.", existingIds.size());
            }

            // 2. CSV 읽기
            log.info("CSV 파일에서 KHOA 조위관측소 위치 정보 읽기 중...");
            List<CsvStationRecord> csvRecords = loadCsvStations();

            if (csvRecords.isEmpty()) {
                log.info("KHOA 조위관측소 CSV 데이터가 없거나 파일을 찾을 수 없어 초기화를 건너뜁니다.");
                return;
            }
            log.info("CSV에서 {}개의 조위관측소 위치 정보 발견", csvRecords.size());

            // 3. 엔티티 생성
            List<MarineStation> stationsToSave = new ArrayList<>();

            for (CsvStationRecord csvRecord : csvRecords) {
                if (existingIds.contains(csvRecord.stationId)) {
                    continue;
                }

                if (csvRecord.lat == null || csvRecord.lon == null ||
                        csvRecord.lat == 0.0 || csvRecord.lon == 0.0) {
                    log.warn("유효하지 않은 좌표: stationId={}, lat={}, lon={}",
                            csvRecord.stationId, csvRecord.lat, csvRecord.lon);
                    continue;
                }

                MarineStation station = MarineStation.builder()
                        .externalSource(StationSource.KHOA_SURVEY_TIDE)
                        .externalStationId(csvRecord.stationId)
                        .name(csvRecord.nameKor != null ? csvRecord.nameKor : csvRecord.nameEng)
                        .lat(csvRecord.lat)
                        .lon(csvRecord.lon)
                        .isActive(true)
                        .build();

                stationsToSave.add(station);
            }

            // 4. 일괄 저장
            if (!stationsToSave.isEmpty()) {
                marineStationRepository.saveAll(stationsToSave);
                log.info("KHOA 조위관측소 데이터 신규 저장 완료: 총 {}개", stationsToSave.size());
            } else {
                log.info("KHOA 조위관측소 데이터가 모두 최신입니다.");
            }

        } catch (Exception e) {
            log.error("KHOA 조위관측소 데이터 초기화 실패", e);
        }
    }

    // --- CSV Parsing Helper Methods ---

    /**
     * NIFS (수산과학원) CSV 파일 로딩
     * 파일명: nifs-stations.csv
     * 인코딩 순서: UTF-8 -> EUC-KR
     */
    private Map<String, NifsStationCsvRecord> loadNifsStationsFromCsv() {
        Map<String, NifsStationCsvRecord> records = new HashMap<>();
        try {
            ClassPathResource resource = new ClassPathResource("nifs-stations.csv");
            if (!resource.exists()) {
                log.warn("nifs-stations.csv 파일을 찾을 수 없습니다. NIFS 관측소 좌표 초기화를 건너뜁니다.");
                return records;
            }

            // UTF-8 우선 시도
            List<Charset> charsets = List.of(StandardCharsets.UTF_8, Charset.forName("EUC-KR"));

            for (Charset charset : charsets) {
                try (BufferedReader reader = new BufferedReader(
                        new InputStreamReader(resource.getInputStream(), charset))) {

                    String line;
                    int lineNumber = 0;
                    while ((line = reader.readLine()) != null) {
                        lineNumber++;
                        if (lineNumber <= 2 || line.trim().isEmpty()) continue; // 헤더 스킵

                        String[] parts = parseCsvLine(line);
                        if (parts.length < 7) continue;

                        try {
                            String stationId = parts[0].trim();
                            String stationName = parts[2].trim();
                            String endDate = parts[4].trim();
                            Double lat = Double.parseDouble(parts[5].trim());
                            Double lon = Double.parseDouble(parts[6].trim());

                            if (stationId.isEmpty() || lat == null || lon == null || !endDate.isEmpty()) {
                                continue;
                            }
                            records.put(stationId, new NifsStationCsvRecord(stationId, stationName, lat, lon));
                        } catch (NumberFormatException ignored) {}
                    }

                    if (!records.isEmpty()) {
                        log.info("NIFS CSV 파일 읽기 성공 (인코딩: {}): {}개 관측소", charset.name(), records.size());
                        return records;
                    }
                } catch (Exception ignored) {}
            }
        } catch (Exception e) {
            log.error("NIFS CSV 파일 읽기 중 오류", e);
        }
        return records;
    }

    /**
     * KHOA (조위관측소) CSV 파일 로딩
     * 파일명: khoa-stations.csv (변경됨!)
     * 포맷: [0]ID, [1]이름, [2]위도, [3]경도
     * 인코딩 순서: UTF-8 -> EUC-KR
     */
    private List<CsvStationRecord> loadCsvStations() {
        List<CsvStationRecord> records = new ArrayList<>();
        try {
            // [파일명 변경] khoa-stations.csv
            ClassPathResource resource = new ClassPathResource("khoa-stations.csv");
            if (!resource.exists()) {
                log.warn("khoa-stations.csv 파일을 찾을 수 없습니다. KHOA 관측소 초기화를 건너뜁니다.");
                return records;
            }

            // UTF-8 우선 시도
            List<Charset> charsets = List.of(StandardCharsets.UTF_8, Charset.forName("EUC-KR"));

            for (Charset charset : charsets) {
                try (BufferedReader reader = new BufferedReader(
                        new InputStreamReader(resource.getInputStream(), charset))) {

                    String line;
                    int lineNumber = 0;
                    while ((line = reader.readLine()) != null) {
                        lineNumber++;
                        // 헤더 스킵 (첫 번째 줄)
                        if (lineNumber == 1) continue;
                        if (line.trim().isEmpty()) continue;

                        String[] parts = parseCsvLine(line);

                        // [수정] 4개 컬럼만 있으면 됨
                        if (parts.length < 4) continue;

                        try {
                            // [0]: ID
                            String stationId = parts[0].trim();
                            // [1]: 이름
                            String nameKor = parts[1].trim();
                            // [2]: 위도
                            Double lat = Double.parseDouble(parts[2].trim());
                            // [3]: 경도
                            Double lon = Double.parseDouble(parts[3].trim());

                            // 영문명 없음
                            String nameEng = "";

                            if (stationId.isEmpty() || lat == null || lon == null) continue;

                            records.add(new CsvStationRecord(stationId, nameKor, nameEng, lat, lon));
                        } catch (NumberFormatException ignored) {}
                    }

                    if (!records.isEmpty()) {
                        log.info("KHOA CSV 파일 읽기 성공 (인코딩: {}): {}개 관측소", charset.name(), records.size());
                        return records;
                    }
                } catch (Exception ignored) {}
            }
        } catch (Exception e) {
            log.error("KHOA CSV 파일 읽기 중 오류", e);
        }
        return records;
    }

    private String[] parseCsvLine(String line) {
        List<String> parts = new ArrayList<>();
        StringBuilder current = new StringBuilder();
        boolean inQuotes = false;
        for (int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if (c == '"') {
                inQuotes = !inQuotes;
            } else if (c == ',' && !inQuotes) {
                parts.add(current.toString());
                current = new StringBuilder();
            } else {
                current.append(c);
            }
        }
        parts.add(current.toString());
        return parts.toArray(new String[0]);
    }

    private static class NifsStationCsvRecord {
        final String stationId;
        final String stationName;
        final Double lat;
        final Double lon;
        NifsStationCsvRecord(String stationId, String stationName, Double lat, Double lon) {
            this.stationId = stationId;
            this.stationName = stationName;
            this.lat = lat;
            this.lon = lon;
        }
    }

    private static class CsvStationRecord {
        final String stationId;
        final String nameKor;
        final String nameEng;
        final Double lat;
        final Double lon;
        CsvStationRecord(String stationId, String nameKor, String nameEng, Double lat, Double lon) {
            this.stationId = stationId;
            this.nameKor = nameKor;
            this.nameEng = nameEng;
            this.lat = lat;
            this.lon = lon;
        }
    }
}


================================================================================
File Path: .\ProjectExporter.java
================================================================================

package com.ocean.piuda.environment;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class ProjectExporter {

    // 결과 파일명
    private static final String OUTPUT_FILE = "project_context.txt";

    // 기본적으로 제외할 디렉토리/파일 (gitignore가 없거나 놓칠 경우 대비)
    private static final Set<String> DEFAULT_IGRORES = new HashSet<>(Arrays.asList(
            ".git", ".idea", ".gradle", "build", "target", "out", ".mvn", "wrapper", "gradlew", "gradlew.bat", OUTPUT_FILE
    ));

    // 텍스트 파일로 간주할 확장자 (바이너리 제외용)
    private static final Set<String> TEXT_EXTENSIONS = new HashSet<>(Arrays.asList(
            "java", "xml", "yml", "yaml", "properties", "gradle", "sql", "md", "txt", "html", "css", "js", "json", "dockerfile"
    ));

    public static void main(String[] args) {
        Path startPath = Paths.get(".");
        Path outputPath = Paths.get(OUTPUT_FILE);
        List<PathMatcher> gitIgnoreMatchers = loadGitIgnore(startPath);

        try (java.io.BufferedWriter writer = Files.newBufferedWriter(outputPath, StandardCharsets.UTF_8)) {
            System.out.println(" 프로젝트 추출을 시작합니다... (Target: " + OUTPUT_FILE + ")");

            Files.walkFileTree(startPath, new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                    if (shouldIgnore(startPath, dir, gitIgnoreMatchers)) {
                        return FileVisitResult.SKIP_SUBTREE;
                    }
                    return FileVisitResult.CONTINUE;
                }

                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                    if (shouldIgnore(startPath, file, gitIgnoreMatchers)) {
                        return FileVisitResult.CONTINUE;
                    }

                    if (isTextFile(file)) {
                        writeFileContent(writer, file);
                    }
                    return FileVisitResult.CONTINUE;
                }
            });

            System.out.println("완료! '" + OUTPUT_FILE + "' 파일이 생성되었습니다.");

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // .gitignore 파일 로드 및 PathMatcher 변환
    private static List<PathMatcher> loadGitIgnore(Path rootPath) {
        List<PathMatcher> matchers = new ArrayList<>();
        Path gitIgnorePath = rootPath.resolve(".gitignore");
        FileSystem fs = FileSystems.getDefault();

        if (Files.exists(gitIgnorePath)) {
            try (Stream<String> lines = Files.lines(gitIgnorePath)) {
                lines.map(String::trim)
                        .filter(line -> !line.isEmpty() && !line.startsWith("#"))
                        .forEach(line -> {
                            // 간단한 glob 패턴 변환 (폴더인 경우 /** 추가 등)
                            String pattern = "glob:**/" + line;
                            if (line.endsWith("/")) {
                                pattern += "**";
                            }
                            try {
                                matchers.add(fs.getPathMatcher(pattern));
                            } catch (Exception e) {
                                // 복잡한 정규식 패턴은 무시
                            }
                        });
                System.out.println("ℹ .gitignore 파일을 발견하여 규칙을 적용합니다.");
            } catch (IOException e) {
                System.err.println("⚠ .gitignore 읽기 실패: " + e.getMessage());
            }
        }
        return matchers;
    }

    // 제외 대상 확인 로직
    private static boolean shouldIgnore(Path root, Path path, List<PathMatcher> gitIgnoreMatchers) {
        String fileName = path.getFileName().toString();

        // 1. 기본 제외 목록 확인
        if (DEFAULT_IGRORES.contains(fileName)) return true;

        // 2. .gitignore 규칙 확인
        for (PathMatcher matcher : gitIgnoreMatchers) {
            if (matcher.matches(path)) return true;
        }

        return false;
    }

    // 텍스트 파일 여부 확인 (확장자 기반)
    private static boolean isTextFile(Path path) {
        String fileName = path.getFileName().toString().toLowerCase();
        if (fileName.equals("dockerfile")) return true;

        int lastDot = fileName.lastIndexOf('.');
        if (lastDot == -1) return false;

        String ext = fileName.substring(lastDot + 1);
        return TEXT_EXTENSIONS.contains(ext);
    }

    private static void writeFileContent(java.io.BufferedWriter writer, Path file) {
        try {
            writer.write("\n" + "=".repeat(80) + "\n");
            writer.write("File Path: " + file.toString() + "\n");
            writer.write("=".repeat(80) + "\n\n");

            // 파일 내용을 한 번에 읽어서 쓰기
            Files.lines(file).forEach(line -> {
                try {
                    writer.write(line);
                    writer.newLine();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            });
            writer.write("\n");
        } catch (Exception e) {
            System.err.println(" 파일 읽기 실패 (" + file + "): " + e.getMessage());
        }
    }
}


================================================================================
File Path: .\properties\MarineApiProperties.java
================================================================================

package com.ocean.piuda.environment.properties;

import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * 해양 환경 API 키 설정 Properties
 */
@Component
@ConfigurationProperties(prefix = "marine")
@Getter
@Setter
public class MarineApiProperties {

    private Nifs nifs = new Nifs();
    private Khoa khoa = new Khoa();
    private Kma kma = new Kma();

    @Getter
    @Setter
    public static class Nifs {
        /**
         * NIFS RISA API 키
         */
        private String key;

        /**
         * NIFS RISA API 호스트 (예: www.nifs.go.kr)
         */
        private String host;

        /**
         * NIFS RISA API 경로 (예: /bweb/OpenAPI_json)
         */
        private String risaPath;
    }

    @Getter
    @Setter
    public static class Khoa {
        /**
         * KHOA 조위 API 키 (URL Encoding)
         */
        private String keyEncoding;

        /**
         * KHOA 조위 API 키 (Decoding)
         */
        private String keyDecoding;

        /**
         * KHOA 조위 API 호스트 (예: apis.data.go.kr)
         */
        private String host;

        /**
         * KHOA 조위 API 경로 (예: /1192136/surveyTideLevel)
         */
        private String tidePath;
    }

    @Getter
    @Setter
    public static class Kma {
        /**
         * KMA 해양기상종합관측 API 키
         */
        private String key;

        /**
         * KMA 해양기상종합관측 API 호스트 (예: apihub.kma.go.kr)
         */
        private String host;

        /**
         * KMA 해양기상종합관측 API 경로 (예: /api/typ01/url/sea_obs.php)
         */
        private String seaObsPath;
    }
}


================================================================================
File Path: .\repository\DivePointRepository.java
================================================================================

package com.ocean.piuda.environment.repository;

import com.ocean.piuda.divePoint.entity.DivePoint;
import org.springframework.data.jpa.repository.JpaRepository;

/**
 * 다이빙 포인트 Repository
 */
public interface DivePointRepository extends JpaRepository<DivePoint, Long> {
    // JpaRepository가 이미 findById(Long)를 제공하므로 별도 선언 불필요
}


================================================================================
File Path: .\repository\MarineStationRepository.java
================================================================================

package com.ocean.piuda.environment.repository;

import com.ocean.piuda.environment.domain.MarineStation;
import com.ocean.piuda.environment.domain.StationSource;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

/**
 * 해양 관측소 Repository
 */
public interface MarineStationRepository extends JpaRepository<MarineStation, Long> {

    /**
     * 외부 소스와 외부 ID로 관측소 조회
     */
    Optional<MarineStation> findByExternalSourceAndExternalStationId(
            StationSource source, String externalStationId);

    /**
     * 활성화된 관측소만 조회
     */
    List<MarineStation> findByExternalSourceAndIsActiveTrue(StationSource source);

    /**
     * 외부 소스로 관측소 삭제
     */
    void deleteByExternalSource(StationSource source);
}



================================================================================
File Path: .\service\EnvironmentSummaryService.java
================================================================================

package com.ocean.piuda.environment.service;

import com.ocean.piuda.environment.dto.EnvironmentSummaryRequest;
import com.ocean.piuda.environment.dto.EnvironmentSummaryResponse;
import reactor.core.publisher.Mono;

/**
 * 해양 환경 요약 서비스 인터페이스
 */
public interface EnvironmentSummaryService {

    /**
     * 해양 환경 요약 조회 (Reactive)
     *
     * @param request 요청 파라미터 (lat/lon 또는 pointId)
     * @return 환경 요약 정보 Mono
     */
    Mono<EnvironmentSummaryResponse> getEnvironmentSummary(EnvironmentSummaryRequest request);
}


================================================================================
File Path: .\service\EnvironmentSummaryServiceImpl.java
================================================================================

package com.ocean.piuda.environment.service;

import com.ocean.piuda.environment.client.KhoaTideClient;
import com.ocean.piuda.environment.client.KmaSeaObsClient;
import com.ocean.piuda.environment.client.NifsRisaClient;
import com.ocean.piuda.divePoint.entity.DivePoint;
import com.ocean.piuda.environment.domain.MarineStation;
import com.ocean.piuda.environment.domain.StationSource;
import com.ocean.piuda.environment.dto.EnvironmentSummaryRequest;
import com.ocean.piuda.environment.dto.EnvironmentSummaryResponse;
import com.ocean.piuda.divePoint.repository.DivePointRepository;
import com.ocean.piuda.environment.repository.MarineStationRepository;
import com.ocean.piuda.environment.util.DistanceCalculator;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;

/**
 * 해양 환경 요약 서비스 구현체 (Reactive)
 */
@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class EnvironmentSummaryServiceImpl implements EnvironmentSummaryService {

    private final NifsRisaClient nifsRisaClient;
    private final KhoaTideClient khoaTideClient;
    private final KmaSeaObsClient kmaSeaObsClient;
    private final MarineStationRepository marineStationRepository;
    private final DivePointRepository divePointRepository;

    private static final ZoneId ZONE_SEOUL = ZoneId.of("Asia/Seoul");

    /**
     * 한 요청 내에서 재사용할 관측소/좌표 컨텍스트
     */
    private record StationContext(
            double lat,
            double lon,
            List<MarineStation> nifsStations,
            List<MarineStation> kmaStations,
            List<MarineStation> khoaStations,
            MarineStation nifsNearest,
            MarineStation kmaNearest,
            MarineStation khoaNearest,
            EnvironmentSummaryResponse.NearestStations nearestStations
    ) {}

    @Override
    public Mono<EnvironmentSummaryResponse> getEnvironmentSummary(EnvironmentSummaryRequest request) {
        // 1) DB 접근 / 관측소 리스트 조회 / 최근접 관측소 선택은 blocking → boundedElastic에서 수행
        return Mono.fromCallable(() -> buildStationContext(request))
                .subscribeOn(Schedulers.boundedElastic())
                // 2) 외부 API는 reactive로 병렬 호출
                .flatMap(ctx -> {
                    Mono<EnvironmentSummaryResponse.Water> waterMono =
                            fetchWaterData(ctx.nifsNearest(), ctx.lat(), ctx.lon(), ctx.nifsStations());

                    Mono<EnvironmentSummaryResponse.Wave> waveMono =
                            fetchWaveData(ctx.kmaNearest(), ctx.lat(), ctx.lon(), ctx.kmaStations());

                    Mono<EnvironmentSummaryResponse.Tide> tideMono =
                            fetchTideData(ctx.khoaNearest());

                    return Mono.zip(
                            waterMono.defaultIfEmpty(EnvironmentSummaryResponse.Water.builder().build()),
                            waveMono.defaultIfEmpty(EnvironmentSummaryResponse.Wave.builder().build()),
                            tideMono.defaultIfEmpty(EnvironmentSummaryResponse.Tide.builder().build())
                    ).map(tuple -> EnvironmentSummaryResponse.builder()
                            .location(EnvironmentSummaryResponse.Location.builder()
                                    .lat(ctx.lat())
                                    .lon(ctx.lon())
                                    .nearestStations(ctx.nearestStations())
                                    .build())
                            .timestamp(ZonedDateTime.now(ZONE_SEOUL))
                            .water(tuple.getT1())
                            .wave(tuple.getT2())
                            .tide(tuple.getT3())
                            .meta(EnvironmentSummaryResponse.Meta.builder()
                                    .rawSources(List.of(
                                            StationSource.NIFS_RISA.name(),
                                            StationSource.KMA_SEA_OBS.name(),
                                            StationSource.KHOA_SURVEY_TIDE.name()
                                    ))
                                    .note("실시간 관측자료는 품질 검증 전 데이터일 수 있음")
                                    .build())
                            .build());
                });
    }

    /**
     * 좌표/포인트 처리 + 관측소 리스트 조회 + 최근접 관측소 선택까지 한 번에 수행
     */
    private StationContext buildStationContext(EnvironmentSummaryRequest request) {
        // 기준 좌표
        double lat;
        double lon;

        if (request.isPointIdBased()) {
            DivePoint point = divePointRepository.findById(request.pointId())
                    .orElseThrow(() -> new IllegalArgumentException("다이빙 포인트를 찾을 수 없습니다: " + request.pointId()));
            lat = point.getLat();
            lon = point.getLon();
        } else if (request.isCoordinateBased()) {
            lat = request.lat();
            lon = request.lon();
        } else {
            throw new IllegalArgumentException("lat/lon 또는 pointId가 필요합니다.");
        }

        log.info("환경 요약 조회 시작: lat={}, lon={}, pointId={}", lat, lon, request.pointId());

        // 관측소 리스트를 각 source별로 딱 한 번씩만 조회
        List<MarineStation> nifsStations =
                marineStationRepository.findByExternalSourceAndIsActiveTrue(StationSource.NIFS_RISA);
        List<MarineStation> kmaStations =
                marineStationRepository.findByExternalSourceAndIsActiveTrue(StationSource.KMA_SEA_OBS);
        List<MarineStation> khoaStations =
                marineStationRepository.findByExternalSourceAndIsActiveTrue(StationSource.KHOA_SURVEY_TIDE);

        MarineStation nifsNearest = findNearestStation(lat, lon, StationSource.NIFS_RISA, nifsStations, khoaStations);
        MarineStation kmaNearest = findNearestStation(lat, lon, StationSource.KMA_SEA_OBS, kmaStations, null);
        MarineStation khoaNearest = findNearestStation(lat, lon, StationSource.KHOA_SURVEY_TIDE, khoaStations, null);

        if (nifsNearest == null && kmaNearest == null && khoaNearest == null) {
            log.warn("모든 관측소 데이터가 없습니다. 관측소 데이터를 초기화해야 합니다.");
        }

        EnvironmentSummaryResponse.NearestStations nearestStations =
                EnvironmentSummaryResponse.NearestStations.builder()
                        .nifs(buildStationInfo(nifsNearest, lat, lon, khoaStations))
                        .kma(buildStationInfo(kmaNearest, lat, lon, null))
                        .khoa(buildStationInfo(khoaNearest, lat, lon, null))
                        .build();

        return new StationContext(
                lat,
                lon,
                nifsStations,
                kmaStations,
                khoaStations,
                nifsNearest,
                kmaNearest,
                khoaNearest,
                nearestStations
        );
    }

    /**
     * 가장 가까운 관측소 찾기 (이미 조회한 리스트 활용)
     */
    private MarineStation findNearestStation(double lat,
                                             double lon,
                                             StationSource source,
                                             List<MarineStation> sourceStations,
                                             List<MarineStation> khoaStationsForNifsFallback) {
        if (sourceStations == null || sourceStations.isEmpty()) {
            log.warn("관측소 데이터가 없습니다: source={}, lat={}, lon={}", source, lat, lon);
            return null;
        }

        // 유효한 좌표를 가진 관측소만
        List<MarineStation> stationsWithLocation = sourceStations.stream()
                .filter(station -> station.getLat() != null && station.getLon() != null)
                .filter(station -> station.getLat() != 0.0 && station.getLon() != 0.0)
                .toList();

        // NIFS RISA 이고 좌표 있는 관측소가 없으면 KHOA 좌표를 참고해서 첫 관측소를 선택
        if (source == StationSource.NIFS_RISA && stationsWithLocation.isEmpty()
                && khoaStationsForNifsFallback != null && !khoaStationsForNifsFallback.isEmpty()) {
            MarineStation nearestKhoa = khoaStationsForNifsFallback.stream()
                    .filter(khoa -> khoa.getLat() != null && khoa.getLon() != null)
                    .filter(khoa -> khoa.getLat() != 0.0 && khoa.getLon() != 0.0)
                    .min(Comparator.comparingDouble(station ->
                            DistanceCalculator.calculateDistance(lat, lon, station.getLat(), station.getLon())))
                    .orElse(null);

            if (nearestKhoa != null) {
                MarineStation nifsStation = sourceStations.get(0); // 좌표 없는 NIFS 중 첫 번째
                double distance = DistanceCalculator.calculateDistance(
                        lat, lon, nearestKhoa.getLat(), nearestKhoa.getLon());
                log.info("NIFS RISA 관측소 매칭 (KHOA 좌표 참고): stationId={}, name={}, khoaStation={}, distance={}km",
                        nifsStation.getExternalStationId(), nifsStation.getName(),
                        nearestKhoa.getName(), Math.round(distance * 10.0) / 10.0);
                return nifsStation;
            }
        }

        if (stationsWithLocation.isEmpty()) {
            log.warn("위치 정보가 있는 관측소가 없습니다: source={}, lat={}, lon={}", source, lat, lon);
            return null;
        }

        MarineStation nearest = stationsWithLocation.stream()
                .min(Comparator.comparingDouble(station ->
                        DistanceCalculator.calculateDistance(lat, lon, station.getLat(), station.getLon())))
                .orElse(null);

        if (nearest != null) {
            double distance = DistanceCalculator.calculateDistance(
                    lat, lon, nearest.getLat(), nearest.getLon());
            log.debug("가장 가까운 관측소 찾음: source={}, stationId={}, name={}, distance={}km",
                    source, nearest.getExternalStationId(), nearest.getName(),
                    Math.round(distance * 10.0) / 10.0);
        }

        return nearest;
    }

    /**
     * 수온/염분/용존산소 데이터 조회 (이미 조회한 NIFS 리스트로 fallback 수행)
     */
    private Mono<EnvironmentSummaryResponse.Water> fetchWaterData(MarineStation station,
                                                                  double requestLat,
                                                                  double requestLon,
                                                                  List<MarineStation> allNifsStations) {
        if (station == null) {
            log.warn("수온 데이터 조회 실패: 관측소가 null입니다");
            return Mono.just(EnvironmentSummaryResponse.Water.builder().build());
        }

        return fetchWaterDataFromStation(station)
                .flatMap(firstResult -> {
                    // 첫 관측소에 유효한 수온 데이터가 있으면 그대로 사용
                    if (firstResult.midLayerTemp() != null || firstResult.surfaceTemp() != null) {
                        return Mono.just(firstResult);
                    }

                    log.info("수온 데이터가 없어 다음 가까운 NIFS RISA 관측소를 시도합니다: stationId={}",
                            station.getExternalStationId());

                    // 이미 조회한 NIFS 관측소 리스트에서 다음 가까운 관측소 찾기
                    List<MarineStation> candidates = allNifsStations.stream()
                            .filter(s -> s.getLat() != null && s.getLon() != null)
                            .filter(s -> s.getLat() != 0.0 && s.getLon() != 0.0)
                            .filter(s -> !Objects.equals(
                                    s.getExternalStationId(), station.getExternalStationId()))
                            .toList();

                    if (candidates.isEmpty()) {
                        log.warn("다음 가까운 NIFS RISA 관측소를 찾을 수 없습니다.");
                        return Mono.just(firstResult);
                    }

                    MarineStation nextStation = candidates.stream()
                            .min(Comparator.comparingDouble(s ->
                                    DistanceCalculator.calculateDistance(
                                            requestLat, requestLon, s.getLat(), s.getLon())))
                            .orElse(null);

                    if (nextStation == null) {
                        log.warn("다음 가까운 NIFS RISA 관측소를 찾을 수 없습니다.");
                        return Mono.just(firstResult);
                    }

                    double distance = DistanceCalculator.calculateDistance(
                            requestLat, requestLon, nextStation.getLat(), nextStation.getLon());
                    log.info("다음 가까운 NIFS RISA 관측소 시도: stationId={}, name={}, distance={}km",
                            nextStation.getExternalStationId(), nextStation.getName(),
                            Math.round(distance * 10.0) / 10.0);

                    return fetchWaterDataFromStation(nextStation)
                            .map(nextResult -> {
                                if (nextResult.midLayerTemp() != null || nextResult.surfaceTemp() != null) {
                                    log.info("다음 관측소에서 수온 데이터 획득: stationId={}, temp={}",
                                            nextStation.getExternalStationId(), nextResult.midLayerTemp());
                                    return nextResult;
                                } else {
                                    log.warn("다음 관측소에서도 수온 데이터를 얻지 못했습니다: stationId={}",
                                            nextStation.getExternalStationId());
                                    return firstResult;
                                }
                            });
                });
    }

    /**
     * 특정 NIFS 관측소에서 수온/염분/용존산소 데이터 조회
     */
    private Mono<EnvironmentSummaryResponse.Water> fetchWaterDataFromStation(MarineStation station) {
        String stationId = station.getExternalStationId();
        log.info("수온 데이터 조회 시작: stationId={}, name={}", stationId, station.getName());

        return nifsRisaClient.fetchLatestObservation(stationId)
                .map(observation -> {
                    Double waterTemp = observation.getWaterTemp();
                    log.info("수온 데이터 조회 성공: stationId={}, temp={}, layer={}",
                            stationId, waterTemp, observation.getObsLayInt());

                    return EnvironmentSummaryResponse.Water.builder()
                            .midLayerTemp(waterTemp)
                            .surfaceTemp(waterTemp) // 중층 데이터를 표층으로도 사용
                            .salinity(observation.getSalinity())
                            .dissolvedOxygen(observation.getDissolvedOxygen())
                            .build();
                })
                .switchIfEmpty(Mono.fromRunnable(() ->
                                log.warn("수온 데이터 조회 실패: observation이 null입니다. stationId={} (API에서 제공하지 않을 수 있음)",
                                        stationId))
                        .then(Mono.just(EnvironmentSummaryResponse.Water.builder().build())))
                .onErrorResume(e -> {
                    log.error("수온 데이터 조회 실패: stationId={}", stationId, e);
                    return Mono.just(EnvironmentSummaryResponse.Water.builder().build());
                });
    }

    /**
     * 파고/풍향/풍속 데이터 조회
     * - 첫 관측소에서 파고만 있고 풍향/풍속이 없으면
     * 미리 조회한 KMA 관측소 리스트를 이용해
     * 최대 9개까지 다른 관측소에서 풍향/풍속을 보충
     */
    private Mono<EnvironmentSummaryResponse.Wave> fetchWaveData(MarineStation station,
                                                                double requestLat,
                                                                double requestLon,
                                                                List<MarineStation> allKmaStations) {
        if (station == null) {
            log.warn("파고 데이터 조회 실패: 관측소가 null입니다");
            return Mono.just(EnvironmentSummaryResponse.Wave.builder().build());
        }

        return fetchWaveDataFromStation(station)
                .flatMap(firstResult -> {
                    Double significantWaveHeight = firstResult.significantWaveHeight();

                    // 풍향/풍속이 있거나, 파고 자체도 없으면 더 시도하지 않음
                    if ((firstResult.windDirectionDeg() != null || firstResult.windSpeedMs() != null)
                            || significantWaveHeight == null) {
                        return Mono.just(firstResult);
                    }

                    log.info("풍향/풍속 데이터가 없어 다음 가까운 KMA 관측소를 시도합니다: stationId={}",
                            station.getExternalStationId());

                    // 이미 조회한 KMA 관측소 리스트에서 fallback 후보 정렬
                    List<MarineStation> candidates = allKmaStations.stream()
                            .filter(s -> s.getLat() != null && s.getLon() != null)
                            .filter(s -> s.getLat() != 0.0 && s.getLon() != 0.0)
                            .filter(s -> !Objects.equals(
                                    s.getExternalStationId(), station.getExternalStationId()))
                            .sorted(Comparator.comparingDouble(s ->
                                    DistanceCalculator.calculateDistance(
                                            requestLat, requestLon, s.getLat(), s.getLon())))
                            .limit(9) // 1차 관측소 포함 총 10개가 되도록 9개까지만 사용
                            .toList();

                    if (candidates.isEmpty()) {
                        log.warn("다음 가까운 KMA 관측소를 찾을 수 없습니다.");
                        return Mono.just(firstResult);
                    }

                    return Flux.fromIterable(candidates)
                            .concatMap(nextStation -> {
                                double distance = DistanceCalculator.calculateDistance(
                                        requestLat, requestLon, nextStation.getLat(), nextStation.getLon());
                                log.info("다음 가까운 KMA 관측소 시도: stationId={}, name={}, distance={}km",
                                        nextStation.getExternalStationId(), nextStation.getName(),
                                        Math.round(distance * 10.0) / 10.0);

                                return fetchWaveDataFromStation(nextStation)
                                        .filter(wave -> wave.windDirectionDeg() != null
                                                || wave.windSpeedMs() != null)
                                        .doOnNext(wave -> log.info("관측소에서 풍향/풍속 데이터 획득: stationId={}, wd={}, ws={}",
                                                nextStation.getExternalStationId(),
                                                wave.windDirectionDeg(), wave.windSpeedMs()));
                            })
                            .next()
                            .map(waveWithWind -> EnvironmentSummaryResponse.Wave.builder()
                                    .significantWaveHeight(significantWaveHeight)
                                    .windDirectionDeg(waveWithWind.windDirectionDeg())
                                    .windSpeedMs(waveWithWind.windSpeedMs())
                                    .build())
                            .switchIfEmpty(Mono.fromRunnable(() ->
                                            log.warn("여러 관측소를 시도했지만 풍향/풍속 데이터를 얻지 못했습니다."))
                                    .then(Mono.just(firstResult)));
                });
    }

    /**
     * 특정 KMA 관측소에서 파고/풍향/풍속 데이터 조회
     */
    private Mono<EnvironmentSummaryResponse.Wave> fetchWaveDataFromStation(MarineStation station) {
        String stationId = station.getExternalStationId();
        log.info("파고 데이터 조회 시작: stationId={}, name={}", stationId, station.getName());

        return kmaSeaObsClient.fetchLatestObservation(stationId)
                .map(observation -> {
                    log.info("파고 데이터 조회 성공: stationId={}, wh={}, wd={}, ws={}",
                            stationId, observation.getWh(), observation.getWd(), observation.getWs());

                    return EnvironmentSummaryResponse.Wave.builder()
                            .significantWaveHeight(observation.getWh())
                            .windDirectionDeg(observation.getWd())
                            .windSpeedMs(observation.getWs())
                            .build();
                })
                .switchIfEmpty(Mono.fromRunnable(() ->
                                log.warn("파고 데이터 조회 실패: observation이 null입니다. stationId={}", stationId))
                        .then(Mono.just(EnvironmentSummaryResponse.Wave.builder().build())))
                .onErrorResume(e -> {
                    log.error("파고 데이터 조회 실패: stationId={}", stationId, e);
                    return Mono.just(EnvironmentSummaryResponse.Wave.builder().build());
                });
    }

    /**
     * 조위 데이터 조회 (Reactive)
     */
    private Mono<EnvironmentSummaryResponse.Tide> fetchTideData(MarineStation station) {
        if (station == null) {
            return Mono.just(EnvironmentSummaryResponse.Tide.builder().build());
        }

        String stationId = station.getExternalStationId();

        return khoaTideClient.fetchLatestTideLevel(stationId)
                .flatMap(observation -> {
                    // 관측시각 파싱 (yyyyMMddHHmm)
                    ZonedDateTime observedAt = null;
                    if (observation.getObsDt() != null && observation.getObsDt().length() >= 12) {
                        try {
                            String dtStr = observation.getObsDt();
                            LocalDate date = LocalDate.parse(dtStr.substring(0, 8),
                                    DateTimeFormatter.ofPattern("yyyyMMdd"));
                            LocalTime time = LocalTime.parse(dtStr.substring(8, 12),
                                    DateTimeFormatter.ofPattern("HHmm"));
                            observedAt = ZonedDateTime.of(date, time, ZONE_SEOUL);
                        } catch (Exception e) {
                            log.warn("조위 관측시각 파싱 실패: {}", observation.getObsDt(), e);
                        }
                    }

                    return Mono.just(EnvironmentSummaryResponse.Tide.builder()
                            .tideLevelCm(observation.getTideLevel())
                            .tideObservedAt(observedAt)
                            .build());
                })
                .switchIfEmpty(Mono.fromRunnable(() ->
                                log.warn("조위 데이터 조회 실패: observation이 null입니다. stationId={}", stationId))
                        .then(Mono.just(EnvironmentSummaryResponse.Tide.builder().build())))
                .onErrorResume(e -> {
                    log.error("조위 데이터 조회 실패: stationId={}", stationId, e);
                    return Mono.just(EnvironmentSummaryResponse.Tide.builder().build());
                });
    }

    /**
     * 관측소 정보 + 거리 정보 빌드
     * - NIFS 좌표가 0.0,0.0인 경우 KHOA 관측소 좌표를 참고해서 거리 계산
     */
    private EnvironmentSummaryResponse.StationInfo buildStationInfo(MarineStation station,
                                                                    double lat,
                                                                    double lon,
                                                                    List<MarineStation> khoaStations) {
        if (station == null) {
            return null;
        }

        double stationLat = station.getLat();
        double stationLon = station.getLon();

        if (station.getExternalSource() == StationSource.NIFS_RISA
                && (stationLat == 0.0 || stationLon == 0.0)
                && khoaStations != null && !khoaStations.isEmpty()) {

            MarineStation nearestKhoa = khoaStations.stream()
                    .filter(s -> s.getLat() != null && s.getLon() != null)
                    .filter(s -> s.getLat() != 0.0 && s.getLon() != 0.0)
                    .min(Comparator.comparingDouble(s ->
                            DistanceCalculator.calculateDistance(lat, lon, s.getLat(), s.getLon())))
                    .orElse(null);

            if (nearestKhoa != null) {
                stationLat = nearestKhoa.getLat();
                stationLon = nearestKhoa.getLon();
            }
        }

        double distance = DistanceCalculator.calculateDistance(lat, lon, stationLat, stationLon);

        return EnvironmentSummaryResponse.StationInfo.builder()
                .id(station.getExternalStationId())
                .name(station.getName())
                .distanceKm(Math.round(distance * 10.0) / 10.0)
                .build();
    }
}


================================================================================
File Path: .\util\DistanceCalculator.java
================================================================================

package com.ocean.piuda.environment.util;

/**
 * 거리 계산 유틸리티
 * Haversine 공식을 사용하여 지구상의 두 지점 간 거리를 계산
 */
public class DistanceCalculator {

    /**
     * 지구 반경 (km)
     */
    private static final double EARTH_RADIUS_KM = 6371.0;

    /**
     * Haversine 공식을 사용하여 두 지점 간 거리 계산 (km)
     *
     * @param lat1 첫 번째 지점의 위도
     * @param lon1 첫 번째 지점의 경도
     * @param lat2 두 번째 지점의 위도
     * @param lon2 두 번째 지점의 경도
     * @return 두 지점 간 거리 (km)
     */
    public static double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
        // 위도와 경도를 라디안으로 변환
        double lat1Rad = Math.toRadians(lat1);
        double lon1Rad = Math.toRadians(lon1);
        double lat2Rad = Math.toRadians(lat2);
        double lon2Rad = Math.toRadians(lon2);

        // 위도와 경도의 차이
        double deltaLat = lat2Rad - lat1Rad;
        double deltaLon = lon2Rad - lon1Rad;

        // Haversine 공식
        double a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2)
                + Math.cos(lat1Rad) * Math.cos(lat2Rad)
                * Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);

        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        // 거리 계산
        return EARTH_RADIUS_KM * c;
    }
}


